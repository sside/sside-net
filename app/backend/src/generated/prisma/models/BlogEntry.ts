/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `BlogEntry` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model BlogEntry
 *
 */
export type BlogEntryModel =
    runtime.Types.Result.DefaultSelection<Prisma.$BlogEntryPayload>;

export type AggregateBlogEntry = {
    _count: BlogEntryCountAggregateOutputType | null;
    _avg: BlogEntryAvgAggregateOutputType | null;
    _sum: BlogEntrySumAggregateOutputType | null;
    _min: BlogEntryMinAggregateOutputType | null;
    _max: BlogEntryMaxAggregateOutputType | null;
};

export type BlogEntryAvgAggregateOutputType = {
    id: number | null;
};

export type BlogEntrySumAggregateOutputType = {
    id: number | null;
};

export type BlogEntryMinAggregateOutputType = {
    id: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    slug: string | null;
    publishAt: Date | null;
};

export type BlogEntryMaxAggregateOutputType = {
    id: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    slug: string | null;
    publishAt: Date | null;
};

export type BlogEntryCountAggregateOutputType = {
    id: number;
    createdAt: number;
    updatedAt: number;
    slug: number;
    publishAt: number;
    _all: number;
};

export type BlogEntryAvgAggregateInputType = {
    id?: true;
};

export type BlogEntrySumAggregateInputType = {
    id?: true;
};

export type BlogEntryMinAggregateInputType = {
    id?: true;
    createdAt?: true;
    updatedAt?: true;
    slug?: true;
    publishAt?: true;
};

export type BlogEntryMaxAggregateInputType = {
    id?: true;
    createdAt?: true;
    updatedAt?: true;
    slug?: true;
    publishAt?: true;
};

export type BlogEntryCountAggregateInputType = {
    id?: true;
    createdAt?: true;
    updatedAt?: true;
    slug?: true;
    publishAt?: true;
    _all?: true;
};

export type BlogEntryAggregateArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Filter which BlogEntry to aggregate.
     */
    where?: Prisma.BlogEntryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BlogEntries to fetch.
     */
    orderBy?:
        | Prisma.BlogEntryOrderByWithRelationInput
        | Prisma.BlogEntryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: Prisma.BlogEntryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` BlogEntries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BlogEntries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned BlogEntries
     **/
    _count?: true | BlogEntryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: BlogEntryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: BlogEntrySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BlogEntryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BlogEntryMaxAggregateInputType;
};

export type GetBlogEntryAggregateType<T extends BlogEntryAggregateArgs> = {
    [P in keyof T & keyof AggregateBlogEntry]: P extends "_count" | "count" ?
        T[P] extends true ?
            number
        :   Prisma.GetScalarType<T[P], AggregateBlogEntry[P]>
    :   Prisma.GetScalarType<T[P], AggregateBlogEntry[P]>;
};

export type BlogEntryGroupByArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    where?: Prisma.BlogEntryWhereInput;
    orderBy?:
        | Prisma.BlogEntryOrderByWithAggregationInput
        | Prisma.BlogEntryOrderByWithAggregationInput[];
    by: Prisma.BlogEntryScalarFieldEnum[] | Prisma.BlogEntryScalarFieldEnum;
    having?: Prisma.BlogEntryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BlogEntryCountAggregateInputType | true;
    _avg?: BlogEntryAvgAggregateInputType;
    _sum?: BlogEntrySumAggregateInputType;
    _min?: BlogEntryMinAggregateInputType;
    _max?: BlogEntryMaxAggregateInputType;
};

export type BlogEntryGroupByOutputType = {
    id: number;
    createdAt: Date;
    updatedAt: Date;
    slug: string;
    publishAt: Date | null;
    _count: BlogEntryCountAggregateOutputType | null;
    _avg: BlogEntryAvgAggregateOutputType | null;
    _sum: BlogEntrySumAggregateOutputType | null;
    _min: BlogEntryMinAggregateOutputType | null;
    _max: BlogEntryMaxAggregateOutputType | null;
};

type GetBlogEntryGroupByPayload<T extends BlogEntryGroupByArgs> =
    Prisma.PrismaPromise<
        Array<
            Prisma.PickEnumerable<BlogEntryGroupByOutputType, T["by"]> & {
                [P in keyof T & keyof BlogEntryGroupByOutputType]: P extends (
                    "_count"
                ) ?
                    T[P] extends boolean ?
                        number
                    :   Prisma.GetScalarType<
                            T[P],
                            BlogEntryGroupByOutputType[P]
                        >
                :   Prisma.GetScalarType<T[P], BlogEntryGroupByOutputType[P]>;
            }
        >
    >;

export type BlogEntryWhereInput = {
    AND?: Prisma.BlogEntryWhereInput | Prisma.BlogEntryWhereInput[];
    OR?: Prisma.BlogEntryWhereInput[];
    NOT?: Prisma.BlogEntryWhereInput | Prisma.BlogEntryWhereInput[];
    id?: Prisma.IntFilter<"BlogEntry"> | number;
    createdAt?: Prisma.DateTimeFilter<"BlogEntry"> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<"BlogEntry"> | Date | string;
    slug?: Prisma.StringFilter<"BlogEntry"> | string;
    publishAt?:
        | Prisma.DateTimeNullableFilter<"BlogEntry">
        | Date
        | string
        | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryListRelationFilter;
    blogEntryDraft?: Prisma.XOR<
        Prisma.BlogEntryDraftNullableScalarRelationFilter,
        Prisma.BlogEntryDraftWhereInput
    > | null;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagListRelationFilter;
};

export type BlogEntryOrderByWithRelationInput = {
    id?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    slug?: Prisma.SortOrder;
    publishAt?: Prisma.SortOrderInput | Prisma.SortOrder;
    blogEntryHistories?: Prisma.BlogEntryHistoryOrderByRelationAggregateInput;
    blogEntryDraft?: Prisma.BlogEntryDraftOrderByWithRelationInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagOrderByRelationAggregateInput;
};

export type BlogEntryWhereUniqueInput = Prisma.AtLeast<
    {
        id?: number;
        slug?: string;
        AND?: Prisma.BlogEntryWhereInput | Prisma.BlogEntryWhereInput[];
        OR?: Prisma.BlogEntryWhereInput[];
        NOT?: Prisma.BlogEntryWhereInput | Prisma.BlogEntryWhereInput[];
        createdAt?: Prisma.DateTimeFilter<"BlogEntry"> | Date | string;
        updatedAt?: Prisma.DateTimeFilter<"BlogEntry"> | Date | string;
        publishAt?:
            | Prisma.DateTimeNullableFilter<"BlogEntry">
            | Date
            | string
            | null;
        blogEntryHistories?: Prisma.BlogEntryHistoryListRelationFilter;
        blogEntryDraft?: Prisma.XOR<
            Prisma.BlogEntryDraftNullableScalarRelationFilter,
            Prisma.BlogEntryDraftWhereInput
        > | null;
        blogEntryMetaTags?: Prisma.BlogEntryMetaTagListRelationFilter;
    },
    "id" | "slug"
>;

export type BlogEntryOrderByWithAggregationInput = {
    id?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    slug?: Prisma.SortOrder;
    publishAt?: Prisma.SortOrderInput | Prisma.SortOrder;
    _count?: Prisma.BlogEntryCountOrderByAggregateInput;
    _avg?: Prisma.BlogEntryAvgOrderByAggregateInput;
    _max?: Prisma.BlogEntryMaxOrderByAggregateInput;
    _min?: Prisma.BlogEntryMinOrderByAggregateInput;
    _sum?: Prisma.BlogEntrySumOrderByAggregateInput;
};

export type BlogEntryScalarWhereWithAggregatesInput = {
    AND?:
        | Prisma.BlogEntryScalarWhereWithAggregatesInput
        | Prisma.BlogEntryScalarWhereWithAggregatesInput[];
    OR?: Prisma.BlogEntryScalarWhereWithAggregatesInput[];
    NOT?:
        | Prisma.BlogEntryScalarWhereWithAggregatesInput
        | Prisma.BlogEntryScalarWhereWithAggregatesInput[];
    id?: Prisma.IntWithAggregatesFilter<"BlogEntry"> | number;
    createdAt?:
        | Prisma.DateTimeWithAggregatesFilter<"BlogEntry">
        | Date
        | string;
    updatedAt?:
        | Prisma.DateTimeWithAggregatesFilter<"BlogEntry">
        | Date
        | string;
    slug?: Prisma.StringWithAggregatesFilter<"BlogEntry"> | string;
    publishAt?:
        | Prisma.DateTimeNullableWithAggregatesFilter<"BlogEntry">
        | Date
        | string
        | null;
};

export type BlogEntryCreateInput = {
    createdAt?: Date | string;
    updatedAt?: Date | string;
    slug: string;
    publishAt?: Date | string | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryCreateNestedManyWithoutBlogEntryInput;
    blogEntryDraft?: Prisma.BlogEntryDraftCreateNestedOneWithoutBlogEntryInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagCreateNestedManyWithoutBlogEntriesInput;
};

export type BlogEntryUncheckedCreateInput = {
    id?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    slug: string;
    publishAt?: Date | string | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryUncheckedCreateNestedManyWithoutBlogEntryInput;
    blogEntryDraft?: Prisma.BlogEntryDraftUncheckedCreateNestedOneWithoutBlogEntryInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagUncheckedCreateNestedManyWithoutBlogEntriesInput;
};

export type BlogEntryUpdateInput = {
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryUpdateManyWithoutBlogEntryNestedInput;
    blogEntryDraft?: Prisma.BlogEntryDraftUpdateOneWithoutBlogEntryNestedInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagUpdateManyWithoutBlogEntriesNestedInput;
};

export type BlogEntryUncheckedUpdateInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryUncheckedUpdateManyWithoutBlogEntryNestedInput;
    blogEntryDraft?: Prisma.BlogEntryDraftUncheckedUpdateOneWithoutBlogEntryNestedInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagUncheckedUpdateManyWithoutBlogEntriesNestedInput;
};

export type BlogEntryCreateManyInput = {
    id?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    slug: string;
    publishAt?: Date | string | null;
};

export type BlogEntryUpdateManyMutationInput = {
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
};

export type BlogEntryUncheckedUpdateManyInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
};

export type BlogEntryCountOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    slug?: Prisma.SortOrder;
    publishAt?: Prisma.SortOrder;
};

export type BlogEntryAvgOrderByAggregateInput = {
    id?: Prisma.SortOrder;
};

export type BlogEntryMaxOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    slug?: Prisma.SortOrder;
    publishAt?: Prisma.SortOrder;
};

export type BlogEntryMinOrderByAggregateInput = {
    id?: Prisma.SortOrder;
    createdAt?: Prisma.SortOrder;
    updatedAt?: Prisma.SortOrder;
    slug?: Prisma.SortOrder;
    publishAt?: Prisma.SortOrder;
};

export type BlogEntrySumOrderByAggregateInput = {
    id?: Prisma.SortOrder;
};

export type BlogEntryScalarRelationFilter = {
    is?: Prisma.BlogEntryWhereInput;
    isNot?: Prisma.BlogEntryWhereInput;
};

export type BlogEntryListRelationFilter = {
    every?: Prisma.BlogEntryWhereInput;
    some?: Prisma.BlogEntryWhereInput;
    none?: Prisma.BlogEntryWhereInput;
};

export type BlogEntryOrderByRelationAggregateInput = {
    _count?: Prisma.SortOrder;
};

export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
};

export type StringFieldUpdateOperationsInput = {
    set?: string;
};

export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
};

export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
};

export type BlogEntryCreateNestedOneWithoutBlogEntryHistoriesInput = {
    create?: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryHistoriesInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryHistoriesInput
    >;
    connectOrCreate?: Prisma.BlogEntryCreateOrConnectWithoutBlogEntryHistoriesInput;
    connect?: Prisma.BlogEntryWhereUniqueInput;
};

export type BlogEntryUpdateOneRequiredWithoutBlogEntryHistoriesNestedInput = {
    create?: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryHistoriesInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryHistoriesInput
    >;
    connectOrCreate?: Prisma.BlogEntryCreateOrConnectWithoutBlogEntryHistoriesInput;
    upsert?: Prisma.BlogEntryUpsertWithoutBlogEntryHistoriesInput;
    connect?: Prisma.BlogEntryWhereUniqueInput;
    update?: Prisma.XOR<
        Prisma.XOR<
            Prisma.BlogEntryUpdateToOneWithWhereWithoutBlogEntryHistoriesInput,
            Prisma.BlogEntryUpdateWithoutBlogEntryHistoriesInput
        >,
        Prisma.BlogEntryUncheckedUpdateWithoutBlogEntryHistoriesInput
    >;
};

export type BlogEntryCreateNestedOneWithoutBlogEntryDraftInput = {
    create?: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryDraftInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryDraftInput
    >;
    connectOrCreate?: Prisma.BlogEntryCreateOrConnectWithoutBlogEntryDraftInput;
    connect?: Prisma.BlogEntryWhereUniqueInput;
};

export type BlogEntryUpdateOneRequiredWithoutBlogEntryDraftNestedInput = {
    create?: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryDraftInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryDraftInput
    >;
    connectOrCreate?: Prisma.BlogEntryCreateOrConnectWithoutBlogEntryDraftInput;
    upsert?: Prisma.BlogEntryUpsertWithoutBlogEntryDraftInput;
    connect?: Prisma.BlogEntryWhereUniqueInput;
    update?: Prisma.XOR<
        Prisma.XOR<
            Prisma.BlogEntryUpdateToOneWithWhereWithoutBlogEntryDraftInput,
            Prisma.BlogEntryUpdateWithoutBlogEntryDraftInput
        >,
        Prisma.BlogEntryUncheckedUpdateWithoutBlogEntryDraftInput
    >;
};

export type BlogEntryCreateNestedManyWithoutBlogEntryMetaTagsInput = {
    create?:
        | Prisma.XOR<
              Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput,
              Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput
          >
        | Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput[]
        | Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput[];
    connectOrCreate?:
        | Prisma.BlogEntryCreateOrConnectWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryCreateOrConnectWithoutBlogEntryMetaTagsInput[];
    connect?:
        | Prisma.BlogEntryWhereUniqueInput
        | Prisma.BlogEntryWhereUniqueInput[];
};

export type BlogEntryUncheckedCreateNestedManyWithoutBlogEntryMetaTagsInput = {
    create?:
        | Prisma.XOR<
              Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput,
              Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput
          >
        | Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput[]
        | Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput[];
    connectOrCreate?:
        | Prisma.BlogEntryCreateOrConnectWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryCreateOrConnectWithoutBlogEntryMetaTagsInput[];
    connect?:
        | Prisma.BlogEntryWhereUniqueInput
        | Prisma.BlogEntryWhereUniqueInput[];
};

export type BlogEntryUpdateManyWithoutBlogEntryMetaTagsNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput,
              Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput
          >
        | Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput[]
        | Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput[];
    connectOrCreate?:
        | Prisma.BlogEntryCreateOrConnectWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryCreateOrConnectWithoutBlogEntryMetaTagsInput[];
    upsert?:
        | Prisma.BlogEntryUpsertWithWhereUniqueWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryUpsertWithWhereUniqueWithoutBlogEntryMetaTagsInput[];
    set?: Prisma.BlogEntryWhereUniqueInput | Prisma.BlogEntryWhereUniqueInput[];
    disconnect?:
        | Prisma.BlogEntryWhereUniqueInput
        | Prisma.BlogEntryWhereUniqueInput[];
    delete?:
        | Prisma.BlogEntryWhereUniqueInput
        | Prisma.BlogEntryWhereUniqueInput[];
    connect?:
        | Prisma.BlogEntryWhereUniqueInput
        | Prisma.BlogEntryWhereUniqueInput[];
    update?:
        | Prisma.BlogEntryUpdateWithWhereUniqueWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryUpdateWithWhereUniqueWithoutBlogEntryMetaTagsInput[];
    updateMany?:
        | Prisma.BlogEntryUpdateManyWithWhereWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryUpdateManyWithWhereWithoutBlogEntryMetaTagsInput[];
    deleteMany?:
        | Prisma.BlogEntryScalarWhereInput
        | Prisma.BlogEntryScalarWhereInput[];
};

export type BlogEntryUncheckedUpdateManyWithoutBlogEntryMetaTagsNestedInput = {
    create?:
        | Prisma.XOR<
              Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput,
              Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput
          >
        | Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput[]
        | Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput[];
    connectOrCreate?:
        | Prisma.BlogEntryCreateOrConnectWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryCreateOrConnectWithoutBlogEntryMetaTagsInput[];
    upsert?:
        | Prisma.BlogEntryUpsertWithWhereUniqueWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryUpsertWithWhereUniqueWithoutBlogEntryMetaTagsInput[];
    set?: Prisma.BlogEntryWhereUniqueInput | Prisma.BlogEntryWhereUniqueInput[];
    disconnect?:
        | Prisma.BlogEntryWhereUniqueInput
        | Prisma.BlogEntryWhereUniqueInput[];
    delete?:
        | Prisma.BlogEntryWhereUniqueInput
        | Prisma.BlogEntryWhereUniqueInput[];
    connect?:
        | Prisma.BlogEntryWhereUniqueInput
        | Prisma.BlogEntryWhereUniqueInput[];
    update?:
        | Prisma.BlogEntryUpdateWithWhereUniqueWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryUpdateWithWhereUniqueWithoutBlogEntryMetaTagsInput[];
    updateMany?:
        | Prisma.BlogEntryUpdateManyWithWhereWithoutBlogEntryMetaTagsInput
        | Prisma.BlogEntryUpdateManyWithWhereWithoutBlogEntryMetaTagsInput[];
    deleteMany?:
        | Prisma.BlogEntryScalarWhereInput
        | Prisma.BlogEntryScalarWhereInput[];
};

export type BlogEntryCreateWithoutBlogEntryHistoriesInput = {
    createdAt?: Date | string;
    updatedAt?: Date | string;
    slug: string;
    publishAt?: Date | string | null;
    blogEntryDraft?: Prisma.BlogEntryDraftCreateNestedOneWithoutBlogEntryInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagCreateNestedManyWithoutBlogEntriesInput;
};

export type BlogEntryUncheckedCreateWithoutBlogEntryHistoriesInput = {
    id?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    slug: string;
    publishAt?: Date | string | null;
    blogEntryDraft?: Prisma.BlogEntryDraftUncheckedCreateNestedOneWithoutBlogEntryInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagUncheckedCreateNestedManyWithoutBlogEntriesInput;
};

export type BlogEntryCreateOrConnectWithoutBlogEntryHistoriesInput = {
    where: Prisma.BlogEntryWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryHistoriesInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryHistoriesInput
    >;
};

export type BlogEntryUpsertWithoutBlogEntryHistoriesInput = {
    update: Prisma.XOR<
        Prisma.BlogEntryUpdateWithoutBlogEntryHistoriesInput,
        Prisma.BlogEntryUncheckedUpdateWithoutBlogEntryHistoriesInput
    >;
    create: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryHistoriesInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryHistoriesInput
    >;
    where?: Prisma.BlogEntryWhereInput;
};

export type BlogEntryUpdateToOneWithWhereWithoutBlogEntryHistoriesInput = {
    where?: Prisma.BlogEntryWhereInput;
    data: Prisma.XOR<
        Prisma.BlogEntryUpdateWithoutBlogEntryHistoriesInput,
        Prisma.BlogEntryUncheckedUpdateWithoutBlogEntryHistoriesInput
    >;
};

export type BlogEntryUpdateWithoutBlogEntryHistoriesInput = {
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    blogEntryDraft?: Prisma.BlogEntryDraftUpdateOneWithoutBlogEntryNestedInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagUpdateManyWithoutBlogEntriesNestedInput;
};

export type BlogEntryUncheckedUpdateWithoutBlogEntryHistoriesInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    blogEntryDraft?: Prisma.BlogEntryDraftUncheckedUpdateOneWithoutBlogEntryNestedInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagUncheckedUpdateManyWithoutBlogEntriesNestedInput;
};

export type BlogEntryCreateWithoutBlogEntryDraftInput = {
    createdAt?: Date | string;
    updatedAt?: Date | string;
    slug: string;
    publishAt?: Date | string | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryCreateNestedManyWithoutBlogEntryInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagCreateNestedManyWithoutBlogEntriesInput;
};

export type BlogEntryUncheckedCreateWithoutBlogEntryDraftInput = {
    id?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    slug: string;
    publishAt?: Date | string | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryUncheckedCreateNestedManyWithoutBlogEntryInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagUncheckedCreateNestedManyWithoutBlogEntriesInput;
};

export type BlogEntryCreateOrConnectWithoutBlogEntryDraftInput = {
    where: Prisma.BlogEntryWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryDraftInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryDraftInput
    >;
};

export type BlogEntryUpsertWithoutBlogEntryDraftInput = {
    update: Prisma.XOR<
        Prisma.BlogEntryUpdateWithoutBlogEntryDraftInput,
        Prisma.BlogEntryUncheckedUpdateWithoutBlogEntryDraftInput
    >;
    create: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryDraftInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryDraftInput
    >;
    where?: Prisma.BlogEntryWhereInput;
};

export type BlogEntryUpdateToOneWithWhereWithoutBlogEntryDraftInput = {
    where?: Prisma.BlogEntryWhereInput;
    data: Prisma.XOR<
        Prisma.BlogEntryUpdateWithoutBlogEntryDraftInput,
        Prisma.BlogEntryUncheckedUpdateWithoutBlogEntryDraftInput
    >;
};

export type BlogEntryUpdateWithoutBlogEntryDraftInput = {
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryUpdateManyWithoutBlogEntryNestedInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagUpdateManyWithoutBlogEntriesNestedInput;
};

export type BlogEntryUncheckedUpdateWithoutBlogEntryDraftInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryUncheckedUpdateManyWithoutBlogEntryNestedInput;
    blogEntryMetaTags?: Prisma.BlogEntryMetaTagUncheckedUpdateManyWithoutBlogEntriesNestedInput;
};

export type BlogEntryCreateWithoutBlogEntryMetaTagsInput = {
    createdAt?: Date | string;
    updatedAt?: Date | string;
    slug: string;
    publishAt?: Date | string | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryCreateNestedManyWithoutBlogEntryInput;
    blogEntryDraft?: Prisma.BlogEntryDraftCreateNestedOneWithoutBlogEntryInput;
};

export type BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput = {
    id?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    slug: string;
    publishAt?: Date | string | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryUncheckedCreateNestedManyWithoutBlogEntryInput;
    blogEntryDraft?: Prisma.BlogEntryDraftUncheckedCreateNestedOneWithoutBlogEntryInput;
};

export type BlogEntryCreateOrConnectWithoutBlogEntryMetaTagsInput = {
    where: Prisma.BlogEntryWhereUniqueInput;
    create: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput
    >;
};

export type BlogEntryUpsertWithWhereUniqueWithoutBlogEntryMetaTagsInput = {
    where: Prisma.BlogEntryWhereUniqueInput;
    update: Prisma.XOR<
        Prisma.BlogEntryUpdateWithoutBlogEntryMetaTagsInput,
        Prisma.BlogEntryUncheckedUpdateWithoutBlogEntryMetaTagsInput
    >;
    create: Prisma.XOR<
        Prisma.BlogEntryCreateWithoutBlogEntryMetaTagsInput,
        Prisma.BlogEntryUncheckedCreateWithoutBlogEntryMetaTagsInput
    >;
};

export type BlogEntryUpdateWithWhereUniqueWithoutBlogEntryMetaTagsInput = {
    where: Prisma.BlogEntryWhereUniqueInput;
    data: Prisma.XOR<
        Prisma.BlogEntryUpdateWithoutBlogEntryMetaTagsInput,
        Prisma.BlogEntryUncheckedUpdateWithoutBlogEntryMetaTagsInput
    >;
};

export type BlogEntryUpdateManyWithWhereWithoutBlogEntryMetaTagsInput = {
    where: Prisma.BlogEntryScalarWhereInput;
    data: Prisma.XOR<
        Prisma.BlogEntryUpdateManyMutationInput,
        Prisma.BlogEntryUncheckedUpdateManyWithoutBlogEntryMetaTagsInput
    >;
};

export type BlogEntryScalarWhereInput = {
    AND?: Prisma.BlogEntryScalarWhereInput | Prisma.BlogEntryScalarWhereInput[];
    OR?: Prisma.BlogEntryScalarWhereInput[];
    NOT?: Prisma.BlogEntryScalarWhereInput | Prisma.BlogEntryScalarWhereInput[];
    id?: Prisma.IntFilter<"BlogEntry"> | number;
    createdAt?: Prisma.DateTimeFilter<"BlogEntry"> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<"BlogEntry"> | Date | string;
    slug?: Prisma.StringFilter<"BlogEntry"> | string;
    publishAt?:
        | Prisma.DateTimeNullableFilter<"BlogEntry">
        | Date
        | string
        | null;
};

export type BlogEntryUpdateWithoutBlogEntryMetaTagsInput = {
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryUpdateManyWithoutBlogEntryNestedInput;
    blogEntryDraft?: Prisma.BlogEntryDraftUpdateOneWithoutBlogEntryNestedInput;
};

export type BlogEntryUncheckedUpdateWithoutBlogEntryMetaTagsInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
    blogEntryHistories?: Prisma.BlogEntryHistoryUncheckedUpdateManyWithoutBlogEntryNestedInput;
    blogEntryDraft?: Prisma.BlogEntryDraftUncheckedUpdateOneWithoutBlogEntryNestedInput;
};

export type BlogEntryUncheckedUpdateManyWithoutBlogEntryMetaTagsInput = {
    id?: Prisma.IntFieldUpdateOperationsInput | number;
    createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
    slug?: Prisma.StringFieldUpdateOperationsInput | string;
    publishAt?:
        | Prisma.NullableDateTimeFieldUpdateOperationsInput
        | Date
        | string
        | null;
};

/**
 * Count Type BlogEntryCountOutputType
 */

export type BlogEntryCountOutputType = {
    blogEntryHistories: number;
    blogEntryMetaTags: number;
};

export type BlogEntryCountOutputTypeSelect<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    blogEntryHistories?:
        | boolean
        | BlogEntryCountOutputTypeCountBlogEntryHistoriesArgs;
    blogEntryMetaTags?:
        | boolean
        | BlogEntryCountOutputTypeCountBlogEntryMetaTagsArgs;
};

/**
 * BlogEntryCountOutputType without action
 */
export type BlogEntryCountOutputTypeDefaultArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntryCountOutputType
     */
    select?: Prisma.BlogEntryCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * BlogEntryCountOutputType without action
 */
export type BlogEntryCountOutputTypeCountBlogEntryHistoriesArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    where?: Prisma.BlogEntryHistoryWhereInput;
};

/**
 * BlogEntryCountOutputType without action
 */
export type BlogEntryCountOutputTypeCountBlogEntryMetaTagsArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    where?: Prisma.BlogEntryMetaTagWhereInput;
};

export type BlogEntrySelect<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        slug?: boolean;
        publishAt?: boolean;
        blogEntryHistories?:
            | boolean
            | Prisma.BlogEntry$blogEntryHistoriesArgs<ExtArgs>;
        blogEntryDraft?: boolean | Prisma.BlogEntry$blogEntryDraftArgs<ExtArgs>;
        blogEntryMetaTags?:
            | boolean
            | Prisma.BlogEntry$blogEntryMetaTagsArgs<ExtArgs>;
        _count?: boolean | Prisma.BlogEntryCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["blogEntry"]
>;

export type BlogEntrySelectCreateManyAndReturn<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        slug?: boolean;
        publishAt?: boolean;
    },
    ExtArgs["result"]["blogEntry"]
>;

export type BlogEntrySelectUpdateManyAndReturn<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
    {
        id?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        slug?: boolean;
        publishAt?: boolean;
    },
    ExtArgs["result"]["blogEntry"]
>;

export type BlogEntrySelectScalar = {
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    slug?: boolean;
    publishAt?: boolean;
};

export type BlogEntryOmit<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
    "id" | "createdAt" | "updatedAt" | "slug" | "publishAt",
    ExtArgs["result"]["blogEntry"]
>;
export type BlogEntryInclude<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    blogEntryHistories?:
        | boolean
        | Prisma.BlogEntry$blogEntryHistoriesArgs<ExtArgs>;
    blogEntryDraft?: boolean | Prisma.BlogEntry$blogEntryDraftArgs<ExtArgs>;
    blogEntryMetaTags?:
        | boolean
        | Prisma.BlogEntry$blogEntryMetaTagsArgs<ExtArgs>;
    _count?: boolean | Prisma.BlogEntryCountOutputTypeDefaultArgs<ExtArgs>;
};
export type BlogEntryIncludeCreateManyAndReturn<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {};
export type BlogEntryIncludeUpdateManyAndReturn<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {};

export type $BlogEntryPayload<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    name: "BlogEntry";
    objects: {
        blogEntryHistories: Prisma.$BlogEntryHistoryPayload<ExtArgs>[];
        blogEntryDraft: Prisma.$BlogEntryDraftPayload<ExtArgs> | null;
        blogEntryMetaTags: Prisma.$BlogEntryMetaTagPayload<ExtArgs>[];
    };
    scalars: runtime.Types.Extensions.GetPayloadResult<
        {
            id: number;
            createdAt: Date;
            updatedAt: Date;
            slug: string;
            publishAt: Date | null;
        },
        ExtArgs["result"]["blogEntry"]
    >;
    composites: {};
};

export type BlogEntryGetPayload<
    S extends boolean | null | undefined | BlogEntryDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$BlogEntryPayload, S>;

export type BlogEntryCountArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<BlogEntryFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: BlogEntryCountAggregateInputType | true;
};

export interface BlogEntryDelegate<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> {
    [K: symbol]: {
        types: Prisma.TypeMap<ExtArgs>["model"]["BlogEntry"];
        meta: { name: "BlogEntry" };
    };
    /**
     * Find zero or one BlogEntry that matches the filter.
     * @param {BlogEntryFindUniqueArgs} args - Arguments to find a BlogEntry
     * @example
     * // Get one BlogEntry
     * const blogEntry = await prisma.blogEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogEntryFindUniqueArgs>(
        args: Prisma.SelectSubset<T, BlogEntryFindUniqueArgs<ExtArgs>>,
    ): Prisma.Prisma__BlogEntryClient<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "findUnique",
            GlobalOmitOptions
        > | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find one BlogEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogEntryFindUniqueOrThrowArgs} args - Arguments to find a BlogEntry
     * @example
     * // Get one BlogEntry
     * const blogEntry = await prisma.blogEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogEntryFindUniqueOrThrowArgs>(
        args: Prisma.SelectSubset<T, BlogEntryFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma.Prisma__BlogEntryClient<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "findUniqueOrThrow",
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first BlogEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogEntryFindFirstArgs} args - Arguments to find a BlogEntry
     * @example
     * // Get one BlogEntry
     * const blogEntry = await prisma.blogEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogEntryFindFirstArgs>(
        args?: Prisma.SelectSubset<T, BlogEntryFindFirstArgs<ExtArgs>>,
    ): Prisma.Prisma__BlogEntryClient<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "findFirst",
            GlobalOmitOptions
        > | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find the first BlogEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogEntryFindFirstOrThrowArgs} args - Arguments to find a BlogEntry
     * @example
     * // Get one BlogEntry
     * const blogEntry = await prisma.blogEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogEntryFindFirstOrThrowArgs>(
        args?: Prisma.SelectSubset<T, BlogEntryFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma.Prisma__BlogEntryClient<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "findFirstOrThrow",
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Find zero or more BlogEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogEntries
     * const blogEntries = await prisma.blogEntry.findMany()
     *
     * // Get first 10 BlogEntries
     * const blogEntries = await prisma.blogEntry.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const blogEntryWithIdOnly = await prisma.blogEntry.findMany({ select: { id: true } })
     *
     */
    findMany<T extends BlogEntryFindManyArgs>(
        args?: Prisma.SelectSubset<T, BlogEntryFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "findMany",
            GlobalOmitOptions
        >
    >;

    /**
     * Create a BlogEntry.
     * @param {BlogEntryCreateArgs} args - Arguments to create a BlogEntry.
     * @example
     * // Create one BlogEntry
     * const BlogEntry = await prisma.blogEntry.create({
     *   data: {
     *     // ... data to create a BlogEntry
     *   }
     * })
     *
     */
    create<T extends BlogEntryCreateArgs>(
        args: Prisma.SelectSubset<T, BlogEntryCreateArgs<ExtArgs>>,
    ): Prisma.Prisma__BlogEntryClient<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "create",
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Create many BlogEntries.
     * @param {BlogEntryCreateManyArgs} args - Arguments to create many BlogEntries.
     * @example
     * // Create many BlogEntries
     * const blogEntry = await prisma.blogEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BlogEntryCreateManyArgs>(
        args?: Prisma.SelectSubset<T, BlogEntryCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Create many BlogEntries and returns the data saved in the database.
     * @param {BlogEntryCreateManyAndReturnArgs} args - Arguments to create many BlogEntries.
     * @example
     * // Create many BlogEntries
     * const blogEntry = await prisma.blogEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many BlogEntries and only return the `id`
     * const blogEntryWithIdOnly = await prisma.blogEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends BlogEntryCreateManyAndReturnArgs>(
        args?: Prisma.SelectSubset<
            T,
            BlogEntryCreateManyAndReturnArgs<ExtArgs>
        >,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "createManyAndReturn",
            GlobalOmitOptions
        >
    >;

    /**
     * Delete a BlogEntry.
     * @param {BlogEntryDeleteArgs} args - Arguments to delete one BlogEntry.
     * @example
     * // Delete one BlogEntry
     * const BlogEntry = await prisma.blogEntry.delete({
     *   where: {
     *     // ... filter to delete one BlogEntry
     *   }
     * })
     *
     */
    delete<T extends BlogEntryDeleteArgs>(
        args: Prisma.SelectSubset<T, BlogEntryDeleteArgs<ExtArgs>>,
    ): Prisma.Prisma__BlogEntryClient<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "delete",
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Update one BlogEntry.
     * @param {BlogEntryUpdateArgs} args - Arguments to update one BlogEntry.
     * @example
     * // Update one BlogEntry
     * const blogEntry = await prisma.blogEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BlogEntryUpdateArgs>(
        args: Prisma.SelectSubset<T, BlogEntryUpdateArgs<ExtArgs>>,
    ): Prisma.Prisma__BlogEntryClient<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "update",
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Delete zero or more BlogEntries.
     * @param {BlogEntryDeleteManyArgs} args - Arguments to filter BlogEntries to delete.
     * @example
     * // Delete a few BlogEntries
     * const { count } = await prisma.blogEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BlogEntryDeleteManyArgs>(
        args?: Prisma.SelectSubset<T, BlogEntryDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more BlogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogEntries
     * const blogEntry = await prisma.blogEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BlogEntryUpdateManyArgs>(
        args: Prisma.SelectSubset<T, BlogEntryUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<Prisma.BatchPayload>;

    /**
     * Update zero or more BlogEntries and returns the data updated in the database.
     * @param {BlogEntryUpdateManyAndReturnArgs} args - Arguments to update many BlogEntries.
     * @example
     * // Update many BlogEntries
     * const blogEntry = await prisma.blogEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more BlogEntries and only return the `id`
     * const blogEntryWithIdOnly = await prisma.blogEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends BlogEntryUpdateManyAndReturnArgs>(
        args: Prisma.SelectSubset<T, BlogEntryUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "updateManyAndReturn",
            GlobalOmitOptions
        >
    >;

    /**
     * Create or update one BlogEntry.
     * @param {BlogEntryUpsertArgs} args - Arguments to update or create a BlogEntry.
     * @example
     * // Update or create a BlogEntry
     * const blogEntry = await prisma.blogEntry.upsert({
     *   create: {
     *     // ... data to create a BlogEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogEntry we want to update
     *   }
     * })
     */
    upsert<T extends BlogEntryUpsertArgs>(
        args: Prisma.SelectSubset<T, BlogEntryUpsertArgs<ExtArgs>>,
    ): Prisma.Prisma__BlogEntryClient<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryPayload<ExtArgs>,
            T,
            "upsert",
            GlobalOmitOptions
        >,
        never,
        ExtArgs,
        GlobalOmitOptions
    >;

    /**
     * Count the number of BlogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogEntryCountArgs} args - Arguments to filter BlogEntries to count.
     * @example
     * // Count the number of BlogEntries
     * const count = await prisma.blogEntry.count({
     *   where: {
     *     // ... the filter for the BlogEntries we want to count
     *   }
     * })
     **/
    count<T extends BlogEntryCountArgs>(
        args?: Prisma.Subset<T, BlogEntryCountArgs>,
    ): Prisma.PrismaPromise<
        T extends runtime.Types.Utils.Record<"select", any> ?
            T["select"] extends true ?
                number
            :   Prisma.GetScalarType<
                    T["select"],
                    BlogEntryCountAggregateOutputType
                >
        :   number
    >;

    /**
     * Allows you to perform aggregations operations on a BlogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BlogEntryAggregateArgs>(
        args: Prisma.Subset<T, BlogEntryAggregateArgs>,
    ): Prisma.PrismaPromise<GetBlogEntryAggregateType<T>>;

    /**
     * Group by BlogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
        T extends BlogEntryGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
            Prisma.Extends<"skip", Prisma.Keys<T>>,
            Prisma.Extends<"take", Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake ?
            { orderBy: BlogEntryGroupByArgs["orderBy"] }
        :   { orderBy?: BlogEntryGroupByArgs["orderBy"] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<
            Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
        >,
        ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T["having"]>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True ?
            `Error: "by" must not be empty.`
        : HavingValid extends Prisma.False ?
            {
                [P in HavingFields]: P extends ByFields ? never
                : P extends string ?
                    `Error: Field "${P}" used in "having" needs to be provided in "by".`
                :   [
                        Error,
                        "Field ",
                        P,
                        ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
        : "take" extends Prisma.Keys<T> ?
            "orderBy" extends Prisma.Keys<T> ?
                ByValid extends Prisma.True ?
                    {}
                :   {
                        [P in OrderFields]: P extends ByFields ? never
                        :   `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
            :   'Error: If you provide "take", you also need to provide "orderBy"'
        : "skip" extends Prisma.Keys<T> ?
            "orderBy" extends Prisma.Keys<T> ?
                ByValid extends Prisma.True ?
                    {}
                :   {
                        [P in OrderFields]: P extends ByFields ? never
                        :   `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
            :   'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends Prisma.True ? {}
        : {
                [P in OrderFields]: P extends ByFields ? never
                :   `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
            }[OrderFields],
    >(
        args: Prisma.SubsetIntersection<T, BlogEntryGroupByArgs, OrderByArg> &
            InputErrors,
    ): {} extends InputErrors ? GetBlogEntryGroupByPayload<T>
    :   Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the BlogEntry model
     */
    readonly fields: BlogEntryFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for BlogEntry.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__BlogEntryClient<
    T,
    Null = never,
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
    GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    blogEntryHistories<
        T extends Prisma.BlogEntry$blogEntryHistoriesArgs<ExtArgs> = {},
    >(
        args?: Prisma.Subset<
            T,
            Prisma.BlogEntry$blogEntryHistoriesArgs<ExtArgs>
        >,
    ): Prisma.PrismaPromise<
        | runtime.Types.Result.GetResult<
              Prisma.$BlogEntryHistoryPayload<ExtArgs>,
              T,
              "findMany",
              GlobalOmitOptions
          >
        | Null
    >;
    blogEntryDraft<T extends Prisma.BlogEntry$blogEntryDraftArgs<ExtArgs> = {}>(
        args?: Prisma.Subset<T, Prisma.BlogEntry$blogEntryDraftArgs<ExtArgs>>,
    ): Prisma.Prisma__BlogEntryDraftClient<
        runtime.Types.Result.GetResult<
            Prisma.$BlogEntryDraftPayload<ExtArgs>,
            T,
            "findUniqueOrThrow",
            GlobalOmitOptions
        > | null,
        null,
        ExtArgs,
        GlobalOmitOptions
    >;
    blogEntryMetaTags<
        T extends Prisma.BlogEntry$blogEntryMetaTagsArgs<ExtArgs> = {},
    >(
        args?: Prisma.Subset<
            T,
            Prisma.BlogEntry$blogEntryMetaTagsArgs<ExtArgs>
        >,
    ): Prisma.PrismaPromise<
        | runtime.Types.Result.GetResult<
              Prisma.$BlogEntryMetaTagPayload<ExtArgs>,
              T,
              "findMany",
              GlobalOmitOptions
          >
        | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
        onfulfilled?:
            | ((value: T) => TResult1 | PromiseLike<TResult1>)
            | undefined
            | null,
        onrejected?:
            | ((reason: any) => TResult2 | PromiseLike<TResult2>)
            | undefined
            | null,
    ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
        onrejected?:
            | ((reason: any) => TResult | PromiseLike<TResult>)
            | undefined
            | null,
    ): runtime.Types.Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(
        onfinally?: (() => void) | undefined | null,
    ): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the BlogEntry model
 */
export interface BlogEntryFieldRefs {
    readonly id: Prisma.FieldRef<"BlogEntry", "Int">;
    readonly createdAt: Prisma.FieldRef<"BlogEntry", "DateTime">;
    readonly updatedAt: Prisma.FieldRef<"BlogEntry", "DateTime">;
    readonly slug: Prisma.FieldRef<"BlogEntry", "String">;
    readonly publishAt: Prisma.FieldRef<"BlogEntry", "DateTime">;
}

// Custom InputTypes
/**
 * BlogEntry findUnique
 */
export type BlogEntryFindUniqueArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
    /**
     * Filter, which BlogEntry to fetch.
     */
    where: Prisma.BlogEntryWhereUniqueInput;
};

/**
 * BlogEntry findUniqueOrThrow
 */
export type BlogEntryFindUniqueOrThrowArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
    /**
     * Filter, which BlogEntry to fetch.
     */
    where: Prisma.BlogEntryWhereUniqueInput;
};

/**
 * BlogEntry findFirst
 */
export type BlogEntryFindFirstArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
    /**
     * Filter, which BlogEntry to fetch.
     */
    where?: Prisma.BlogEntryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BlogEntries to fetch.
     */
    orderBy?:
        | Prisma.BlogEntryOrderByWithRelationInput
        | Prisma.BlogEntryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BlogEntries.
     */
    cursor?: Prisma.BlogEntryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` BlogEntries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BlogEntries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BlogEntries.
     */
    distinct?:
        | Prisma.BlogEntryScalarFieldEnum
        | Prisma.BlogEntryScalarFieldEnum[];
};

/**
 * BlogEntry findFirstOrThrow
 */
export type BlogEntryFindFirstOrThrowArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
    /**
     * Filter, which BlogEntry to fetch.
     */
    where?: Prisma.BlogEntryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BlogEntries to fetch.
     */
    orderBy?:
        | Prisma.BlogEntryOrderByWithRelationInput
        | Prisma.BlogEntryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BlogEntries.
     */
    cursor?: Prisma.BlogEntryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` BlogEntries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BlogEntries.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BlogEntries.
     */
    distinct?:
        | Prisma.BlogEntryScalarFieldEnum
        | Prisma.BlogEntryScalarFieldEnum[];
};

/**
 * BlogEntry findMany
 */
export type BlogEntryFindManyArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
    /**
     * Filter, which BlogEntries to fetch.
     */
    where?: Prisma.BlogEntryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BlogEntries to fetch.
     */
    orderBy?:
        | Prisma.BlogEntryOrderByWithRelationInput
        | Prisma.BlogEntryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing BlogEntries.
     */
    cursor?: Prisma.BlogEntryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `Â±n` BlogEntries from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BlogEntries.
     */
    skip?: number;
    distinct?:
        | Prisma.BlogEntryScalarFieldEnum
        | Prisma.BlogEntryScalarFieldEnum[];
};

/**
 * BlogEntry create
 */
export type BlogEntryCreateArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
    /**
     * The data needed to create a BlogEntry.
     */
    data: Prisma.XOR<
        Prisma.BlogEntryCreateInput,
        Prisma.BlogEntryUncheckedCreateInput
    >;
};

/**
 * BlogEntry createMany
 */
export type BlogEntryCreateManyArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * The data used to create many BlogEntries.
     */
    data: Prisma.BlogEntryCreateManyInput | Prisma.BlogEntryCreateManyInput[];
};

/**
 * BlogEntry createManyAndReturn
 */
export type BlogEntryCreateManyAndReturnArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * The data used to create many BlogEntries.
     */
    data: Prisma.BlogEntryCreateManyInput | Prisma.BlogEntryCreateManyInput[];
};

/**
 * BlogEntry update
 */
export type BlogEntryUpdateArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
    /**
     * The data needed to update a BlogEntry.
     */
    data: Prisma.XOR<
        Prisma.BlogEntryUpdateInput,
        Prisma.BlogEntryUncheckedUpdateInput
    >;
    /**
     * Choose, which BlogEntry to update.
     */
    where: Prisma.BlogEntryWhereUniqueInput;
};

/**
 * BlogEntry updateMany
 */
export type BlogEntryUpdateManyArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * The data used to update BlogEntries.
     */
    data: Prisma.XOR<
        Prisma.BlogEntryUpdateManyMutationInput,
        Prisma.BlogEntryUncheckedUpdateManyInput
    >;
    /**
     * Filter which BlogEntries to update
     */
    where?: Prisma.BlogEntryWhereInput;
    /**
     * Limit how many BlogEntries to update.
     */
    limit?: number;
};

/**
 * BlogEntry updateManyAndReturn
 */
export type BlogEntryUpdateManyAndReturnArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * The data used to update BlogEntries.
     */
    data: Prisma.XOR<
        Prisma.BlogEntryUpdateManyMutationInput,
        Prisma.BlogEntryUncheckedUpdateManyInput
    >;
    /**
     * Filter which BlogEntries to update
     */
    where?: Prisma.BlogEntryWhereInput;
    /**
     * Limit how many BlogEntries to update.
     */
    limit?: number;
};

/**
 * BlogEntry upsert
 */
export type BlogEntryUpsertArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
    /**
     * The filter to search for the BlogEntry to update in case it exists.
     */
    where: Prisma.BlogEntryWhereUniqueInput;
    /**
     * In case the BlogEntry found by the `where` argument doesn't exist, create a new BlogEntry with this data.
     */
    create: Prisma.XOR<
        Prisma.BlogEntryCreateInput,
        Prisma.BlogEntryUncheckedCreateInput
    >;
    /**
     * In case the BlogEntry was found with the provided `where` argument, update it with this data.
     */
    update: Prisma.XOR<
        Prisma.BlogEntryUpdateInput,
        Prisma.BlogEntryUncheckedUpdateInput
    >;
};

/**
 * BlogEntry delete
 */
export type BlogEntryDeleteArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
    /**
     * Filter which BlogEntry to delete.
     */
    where: Prisma.BlogEntryWhereUniqueInput;
};

/**
 * BlogEntry deleteMany
 */
export type BlogEntryDeleteManyArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Filter which BlogEntries to delete
     */
    where?: Prisma.BlogEntryWhereInput;
    /**
     * Limit how many BlogEntries to delete.
     */
    limit?: number;
};

/**
 * BlogEntry.blogEntryHistories
 */
export type BlogEntry$blogEntryHistoriesArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntryHistory
     */
    select?: Prisma.BlogEntryHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntryHistory
     */
    omit?: Prisma.BlogEntryHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryHistoryInclude<ExtArgs> | null;
    where?: Prisma.BlogEntryHistoryWhereInput;
    orderBy?:
        | Prisma.BlogEntryHistoryOrderByWithRelationInput
        | Prisma.BlogEntryHistoryOrderByWithRelationInput[];
    cursor?: Prisma.BlogEntryHistoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
        | Prisma.BlogEntryHistoryScalarFieldEnum
        | Prisma.BlogEntryHistoryScalarFieldEnum[];
};

/**
 * BlogEntry.blogEntryDraft
 */
export type BlogEntry$blogEntryDraftArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntryDraft
     */
    select?: Prisma.BlogEntryDraftSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntryDraft
     */
    omit?: Prisma.BlogEntryDraftOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryDraftInclude<ExtArgs> | null;
    where?: Prisma.BlogEntryDraftWhereInput;
};

/**
 * BlogEntry.blogEntryMetaTags
 */
export type BlogEntry$blogEntryMetaTagsArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntryMetaTag
     */
    select?: Prisma.BlogEntryMetaTagSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntryMetaTag
     */
    omit?: Prisma.BlogEntryMetaTagOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryMetaTagInclude<ExtArgs> | null;
    where?: Prisma.BlogEntryMetaTagWhereInput;
    orderBy?:
        | Prisma.BlogEntryMetaTagOrderByWithRelationInput
        | Prisma.BlogEntryMetaTagOrderByWithRelationInput[];
    cursor?: Prisma.BlogEntryMetaTagWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
        | Prisma.BlogEntryMetaTagScalarFieldEnum
        | Prisma.BlogEntryMetaTagScalarFieldEnum[];
};

/**
 * BlogEntry without action
 */
export type BlogEntryDefaultArgs<
    ExtArgs extends
        runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
    /**
     * Select specific fields to fetch from the BlogEntry
     */
    select?: Prisma.BlogEntrySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BlogEntry
     */
    omit?: Prisma.BlogEntryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Prisma.BlogEntryInclude<ExtArgs> | null;
};
